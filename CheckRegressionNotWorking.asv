Installation();

% Initial subyacent price
S0 = 100;

% Definition of the interestRate function for an annual continiously compounded interest rate of 5%
interestRate = @(actualDate) ones(size(actualDate)) .* 0;

% Definition of the volatility function for a 0% volatility
% (and so, get a defined subyacent price path)
volatility = @(actualDate) ones(size(actualDate)) .* 5; 

% define the step size as 1 minute:
stepSize = days(1);

% Define the valuation date and the maturity to have a 10 year
% price path
valuationDate = datetime(2021,01,01);
maturity = datetime(2021,01,03);

% Generate only one path
numberOfPaths = 4;

[pricePath, stepDatetimeArray, interestRateArray] = generatePathUsingWienerProcess(S0, interestRate, volatility, stepSize, valuationDate, maturity, numberOfPaths);


% Call with Strike is 100
Strike = 100;

actualPath = pricePath(:,end);

nextPath = pricePath(:,end-1);

% Is a call strike 100 so the paths in the money are:
filter = actualPath > Strike;

% The actual and next paths to make regression are:
actualPath = actualPath(filter);

nextPath = nextPath(filter);

V = max(nextPath - Strike, 0); % Payout of the next path

% As interest rate = 0, discount factor = 1 so:
%present value of the nextPath = nextPath.


% For matlab, if we have a system of linear equations Ax=b and A is a
% rectangular mxn matrix (m = rows, n=columns) with m>n, then A\b returns
% the least-square solution of the system of linear equations.


A = [ones(size(actualPath)), actualPath, actualPath.^2]






X1 = Sfiltered./S0;

A = [ones(size(X1)), (1-X1), 1/2.*(2-4.*X1 - X1.^2)];

x = A\V; % Linear regression (Getting the A,B and C regression coeficients) 

