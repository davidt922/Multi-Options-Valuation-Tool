% This test consist to check the correct behavour of the
% generatePathUsingGBM function, we sill check:


%% Test Class Definition
classdef Test_2_optionValuation < matlab.unittest.TestCase

    methods(TestMethodSetup)
        function setup(testCase)
            % Install all project functions to get access to it:
            Installation();
        end
    end

    methods (Test)
        % We are using a montecarlo method to valuate options that consist
        % of generate several subyacent price paths. Check, for each path,
        % the payout that the option will give and finally find the mean of
        % all the discounted payouts to find the actual value of the option.

        % In this tests we will check if our optionValuation function (Function
        % that having the subyacent paths returns the option value) works
        % correctly.

        % The first test consist of valuating a Call European option. with
        % a subyacent value of 100 and a strike of 100 with a 1 year
        % maturity
        function testEuropeanOptionValuation(testCase)
            % Import required functions for testing purposes
            import matlab.unittest.constraints.IsEqualTo;
            import matlab.unittest.constraints.RelativeTolerance;

            % Maximum relative tolerance of 1%
            reltol = 0.01;

            % this function defines when the holder of the option can
            % exercice the option, for European Options this is only
            % possible at maturity so it can only exercited on the last
            % quoting day so:
            exerciceFunction_ = @(actualDate, maturityDate, stepSize)   isbetween(actualDate, maturityDate - days(1), maturityDate + days(1));

            % For this option we don't have a barrier so:
            barrier_ = @(subyacentPrice) ones(size(subyacentPrice)).*-1;
            subyacentValue = 100;

            strikeValue = 100;

            % The strike of the option is 100, so the payoff function will
            % be the maximum between the diference of the subyacent price
            % and the strike and 0:
            % Notice, doesn't matter if, for each path it gives the payoff
            % as the moments in time that can be executed will be decided
            % by the exerciceFunction_
            payoff_ = @(subyacentPrice, actualDate, maturityDate)  max(subyacentPrice - strikeValue, 0);


            % Define the prices path, remember, each column represents a
            % point in time using as increments the time step and each row
            % represents a price path of the subyacent asset (this path is
            % generated by the generatePathUsingGBM but the path shown is
            % created randomly for unit testing purposes.
            path = [100, 101, 120.3, 100, 102, 101, 99;...
                    100, 99,  98.3,  99.2,88,  87,  86;...
                    100, 121, 151,   143, 132, 130, 123; ...
                    100, 101, 120,   121, 124, 125, 117];

            % To reduce the complexity of the unit test we suppose that the
            % interestRate is 0.
            interestRate = zeros(size(path));

            % Having this path, the expected
            % payoff for an European Call with a strike = 100 will be:
            % mean(max(99-100, 0), max(86-100,0), max(123-100, 0), max(117-100,0))
            % As interest rate is 0, this will be the price of the option
            % with a non arbitratge world so, expectedOptionPrice = 1/4*(0+0+23+17) = 10
            expectedOptionPrice = mean(max(path(:,end) - strikeValue, 0));


            % Define the step size as 1 year, this will not be used as in meanPayout
            % stepSize is used to move money in time, but as interest rate
            % is 0, money have the same value all the time.
            % (It seems that the stepSize have to be used somehow for the
            % volatility of the subyacents path, but that is not true as
            % the volatility of the subyacent is included in the price path
            % as shown in Test_1_GeneratePathUsingGBM,
            stepSize = years(1);

            % Create the step datetime array, taking in account that
            % stepSize is 1 year:
            stepDatetimeArray = [datetime(2021,1,1), datetime(2022,1,1), datetime(2023,1,1), datetime(2024,1,1),...
                                 datetime(2025,1,1), datetime(2026,1,1), datetime(2027,1,1)];

           stepDatetimeArray = repmat(stepDatetimeArray,4,1);

            % Define the valuation date and the maturity (from
            % stepDatetimeArray)
            valuationDate = datetime(2021,1,1);
            maturity = datetime(2027,1,1);


            optionValue = optionValuation(exerciceFunction_, barrier_, payoff_, path, stepDatetimeArray, interestRate, maturity, stepSize);

            fprintf("Expected European Option Value %f\n", expectedOptionPrice)
            fprintf("Valuated European Option Value %f\n\n", optionValue)
            testCase.verifyThat(optionValue, IsEqualTo(expectedOptionPrice, 'Within', RelativeTolerance(reltol)));
            
            
            % Now we will change the subyacent price path and the strike we will
            % valuate again:
            path = [100, 78, 110.3, 120, 112, 114, 100;...
                    100, 99, 108.3,109.2,108,  99,  106;...
                    100, 102, 131,   113, 152, 110, 113; ...
                    100, 111, 117,   131, 126, 125, 97];
                
            strikeValue = 98;
            payoff_ = @(subyacentPrice, actualDate, maturityDate)  max(subyacentPrice - strikeValue, 0);
            expectedOptionPrice = mean(max(path(:,end) - strikeValue, 0));
           
            optionValue = optionValuation(exerciceFunction_, barrier_, payoff_, path, stepDatetimeArray, interestRate, maturity, stepSize);

            fprintf("Expected European Option Value %f\n", expectedOptionPrice)
            fprintf("Valuated European Option Value %f\n\n", optionValue)
            testCase.verifyThat(optionValue, IsEqualTo(expectedOptionPrice, 'Within', RelativeTolerance(reltol)));
        end
        
        % In this second test we will valuate the same options as in the
        % first test but introducing a barrier with rebate. We can use any
        % Barrier definition, but in our case we will use a Knock-out
        % Barrier, that will disable the option if, during the life of the
        % option, the subyacent surpases the barrier.
        function testEuropeanOptionWithBarrier(testCase)
                        % Import required functions for testing purposes
            import matlab.unittest.constraints.IsEqualTo;
            import matlab.unittest.constraints.RelativeTolerance;

            % Maximum relative tolerance of 1%
            reltol = 0.01;

            % this function defines when the holder of the option can
            % exercice the option, for European Options this is only
            % possible at maturity so it can only exercited on the last
            % quoting day so:
            exerciceFunction_ = @(actualDate, maturityDate, stepSize)   isbetween(actualDate, maturityDate - days(1), maturityDate + days(1));

            % Defining a barrier that activates when the subyacent price is
            % bigger that 121 and have a rebate value of 2
            rebate = 2;
            barrierBreakPoint = 121;
            barrier_ = @(subyacentPrice) (zeros(size(subyacentPrice)))+((subyacentPrice>=barrierBreakPoint).*rebate)+((subyacentPrice<barrierBreakPoint).*-1);
            
            subyacentValue = 100;

            strikeValue = 100;

            % The strike of the option is 100, so the payoff function will
            % be the maximum between the diference of the subyacent price
            % and the strike and 0:
            % Notice, doesn't matter if, for each path it gives the payoff
            % as the moments in time that can be executed will be decided
            % by the exerciceFunction_
            payoff_ = @(subyacentPrice, actualDate, maturityDate)  max(subyacentPrice - strikeValue, 0);


            % Define the prices path, remember, each column represents a
            % point in time using as increments the time step and each row
            % represents a price path of the subyacent asset (this path is
            % generated by the generatePathUsingGBM but the path shown is
            % created randomly for unit testing purposes.
            % For this paths the barrier will be crossed in the last two,
            % giving a rebtate of 2.
            path = [100, 101, 120.3, 100, 102, 101, 99;...
                    100, 99,  98.3,  99.2,88,  87,  86;...
                    100, 121, 151,   143, 132, 130, 123; ...
                    100, 101, 120,   121, 124, 125, 117];

            % To reduce the complexity of the unit test we suppose that the
            % interestRate is 0.
            interestRate = zeros(size(path));

            % Having this path, the expected
            % payoff for an European Call with a strike = 100 and with a barrier at 121 and a rebate value of 3
            % will be:
            % mean(max(99-100, 0), max(86-100,0), 3, 3)
            % As interest rate is 0, this will be the price of the option
            % with a non arbitratge world so, expectedOptionPrice =
            % 1/4*(0+0+2+2) = 1
            expectedOptionPrice = 1;


            % Define the step size as 1 year, this will not be used as in meanPayout
            % stepSize is used to move money in time, but as interest rate
            % is 0, money have the same value all the time.
            % (It seems that the stepSize have to be used somehow for the
            % volatility of the subyacents path, but that is not true as
            % the volatility of the subyacent is included in the price path
            % as shown in Test_1_GeneratePathUsingGBM,
            stepSize = years(1);

            % Create the step datetime array, taking in account that
            % stepSize is 1 year:
            stepDatetimeArray = [datetime(2021,1,1), datetime(2022,1,1), datetime(2023,1,1), datetime(2024,1,1),...
                                 datetime(2025,1,1), datetime(2026,1,1), datetime(2027,1,1)];

           stepDatetimeArray = repmat(stepDatetimeArray,4,1);

            % Define the valuation date and the maturity (from
            % stepDatetimeArray)
            valuationDate = datetime(2021,1,1);
            maturity = datetime(2027,1,1);


            optionValue = optionValuation(exerciceFunction_, barrier_, payoff_, path, stepDatetimeArray, interestRate, maturity, stepSize);

            fprintf("Expected European Option Value with a barrier %f\n", expectedOptionPrice)
            fprintf("Valuated European Option Value with a barrier %f\n\n", optionValue)
            testCase.verifyThat(optionValue, IsEqualTo(expectedOptionPrice, 'Within', RelativeTolerance(reltol)));
            
            
            % Now we will change the subyacent price path and the strike we will
            % valuate again:
            path = [100, 78, 110.3, 120, 112, 114, 100;...
                    100, 99, 108.3,109.2,108,  99,  106;...
                    100, 102, 131,   113, 152, 110, 113; ...
                    100, 111, 117,   131, 126, 125, 97];
                
            strikeValue = 98;
            payoff_ = @(subyacentPrice, actualDate, maturityDate)  max(subyacentPrice - strikeValue, 0);
            % Using the same barrier, as before the barrier will be crossed
            % in the last two paths so expectedOptionPrice = 1/4*(2+8+2+2)
            % = 3.5
            expectedOptionPrice = 3.5;
           
            optionValue = optionValuation(exerciceFunction_, barrier_, payoff_, path, stepDatetimeArray, interestRate, maturity, stepSize);

            fprintf("Expected European Option Value with a barrier %f\n", expectedOptionPrice)
            fprintf("Valuated European Option Value with a barrier %f\n\n", optionValue)
            testCase.verifyThat(optionValue, IsEqualTo(expectedOptionPrice, 'Within', RelativeTolerance(reltol)));
        end
        
        % Asian Options works in the same way as European Options with the
        % diference that at maturity, the payoff depends on the average
        % price of the underlying asset over a certain period of time.
        
        % For this unit testing we will use the same subyacent paths and option 
        % definition as the first test cases changing that the maturity price will be the 
        % average price of the last 2 quotes.
        function testAsianOption(testCase)
            % Import required functions for testing purposes
            import matlab.unittest.constraints.IsEqualTo;
            import matlab.unittest.constraints.RelativeTolerance;

            % Maximum relative tolerance of 1%
            reltol = 0.01;

            % this function defines when the holder of the option can
            % exercice the option, for the Asian Options this is only
            % possible at maturity so it can only exercited on the last
            % quoting day so:
            exerciceFunction_ = @(actualDate, maturityDate, stepSize)   isbetween(actualDate, maturityDate - days(1), maturityDate + days(1));

            % For this option we don't have a barrier so:
            barrier_ = @(subyacentPrice) ones(size(subyacentPrice)).*-1;
            subyacentValue = 100;

            strikeValue = 100;
            
            
            % The strike of the option is 100, so the payoff function will
            % be the maximum between the diference of the mean of the
            % subyacent price for the last two quoting days
            % What we are doing here is compute the mean price of two
            % conseutive quoting days and, as doing this whe loose the
            % first position time column we add it again:
            % Example:
            % If subyacentPriceMatrix is:
            % 1, 2, 3
            % 1, 3, 6
            % 1, 5, 9
    
            % Then we compute the mean of 2 consecutive values with
            % (subyacentPrice(:,2:end)+subyacentPrice(:,1:end-1))./2
            % getting:
            % 1.5,  2.5
            % 2.0,  4.5
            % 3.0,  7.0
            % so we add again the first colum to have a matrix with the
            % same dimension as the original one having finally:
            % 1, 1.5,  2.5
            % 1, 2.0,  4.5
            % 1, 3.0,  7.0      
            
            % Notice, doesn't matter if, for each path it gives the payoff
            % as the moments in time that can be executed will be decided
            % by the exerciceFunction_
            payoff_ = @(subyacentPrice, actualDate, maturityDate)  max([ones(size(subyacentPrice,1),1).*subyacentValue,...
                (subyacentPrice(:,2:end)+subyacentPrice(:,1:end-1))./2] - strikeValue, 0);


            % Define the prices path, remember, each column represents a
            % point in time using as increments the time step and each row
            % represents a price path of the subyacent asset (this path is
            % generated by the generatePathUsingGBM but the path shown is
            % created randomly for unit testing purposes.
            path = [100, 101, 120.3, 100, 102, 101, 99;...
                    100, 99,  98.3,  99.2,88,  87,  86;...
                    100, 121, 151,   143, 132, 130, 123; ...
                    100, 101, 120,   121, 124, 125, 117];

            % To reduce the complexity of the unit test we suppose that the
            % interestRate is 0.
            interestRate = zeros(size(path));

            % Having this path, the expected
            % payoff for an Asian Call with a strike = 100 will be the mean
            % for each path of the maximum between the mean value of the two last quotation days
            % and the strike.
            
            % mean(max((101+99)/2-100, 0), max((87+86)/2-100,0), max((130+123)/2-100, 0), max((125+117)/2-100,0))
            % As interest rate is 0, this will be the price of the option
            % with a non arbitratge world so, expectedOptionPrice = 1/4*(0+0+26.5+21) = 11.875
            expectedOptionPrice = mean( max( mean([path(:,end),path(:,end-1)],2) - strikeValue, 0));

            % Define the step size as 1 year, this will not be used as in meanPayout
            % stepSize is used to move money in time, but as interest rate
            % is 0, money have the same value all the time.
            % (It seems that the stepSize have to be used somehow for the
            % volatility of the subyacents path, but that is not true as
            % the volatility of the subyacent is included in the price path
            % as shown in Test_1_GeneratePathUsingGBM,
            stepSize = years(1);

            % Create the step datetime array, taking in account that
            % stepSize is 1 year:
            stepDatetimeArray = [datetime(2021,1,1), datetime(2022,1,1), datetime(2023,1,1), datetime(2024,1,1),...
                                 datetime(2025,1,1), datetime(2026,1,1), datetime(2027,1,1)];

           stepDatetimeArray = repmat(stepDatetimeArray,4,1);

            % Define the valuation date and the maturity (from
            % stepDatetimeArray)
            valuationDate = datetime(2021,1,1);
            maturity = datetime(2027,1,1);


            optionValue = optionValuation(exerciceFunction_, barrier_, payoff_, path, stepDatetimeArray, interestRate, maturity, stepSize);

            fprintf("Expected Asian Option Value %f\n", expectedOptionPrice)
            fprintf("Valuated Asian Option Value %f\n\n", optionValue)
            testCase.verifyThat(optionValue, IsEqualTo(expectedOptionPrice, 'Within', RelativeTolerance(reltol)));
            
            
            % Now we will change the subyacent price path and the strike we will
            % valuate again:
            path = [100, 78, 110.3, 120, 112, 114, 100;...
                    100, 99, 108.3,109.2,108,  99,  106;...
                    100, 102, 131,   113, 152, 110, 113; ...
                    100, 111, 117,   131, 126, 125, 97];
                
            strikeValue = 98;
            payoff_ = @(subyacentPrice, actualDate, maturityDate)  max([ones(size(subyacentPrice,1),1).*subyacentValue,...
                (subyacentPrice(:,2:end)+subyacentPrice(:,1:end-1))./2] - strikeValue, 0);
            expectedOptionPrice = mean( max( mean([path(:,end),path(:,end-1)],2) - strikeValue, 0));
           
            optionValue = optionValuation(exerciceFunction_, barrier_, payoff_, path, stepDatetimeArray, interestRate, maturity, stepSize);

            fprintf("Expected Asian Option Value %f\n", expectedOptionPrice)
            fprintf("Valuated Asian Option Value %f\n\n", optionValue)
            testCase.verifyThat(optionValue, IsEqualTo(expectedOptionPrice, 'Within', RelativeTolerance(reltol)));  
        end


    end

end
